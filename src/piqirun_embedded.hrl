%% Copyright 2009, 2010, 2011, 2012, 2013, 2014 Anton Lavrik
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%
%% This module reuses some code from Protobuffs library. The original code was
%% taken from here:
%%      http://github.com/ngerakines/erlang_protobuffs
%%
%% Below is the original copyright notice and the license:
%%
%% Copyright (c) 2009 
%% Nick Gerakines <nick@gerakines.net>
%% Jacob Vorreuter <jacob.vorreuter@gmail.com>
%%
%% Permission is hereby granted, free of charge, to any person
%% obtaining a copy of this software and associated documentation
%% files (the "Software"), to deal in the Software without
%% restriction, including without limitation the rights to use,
%% copy, modify, merge, publish, distribute, sublicense, and/or sell
%% copies of the Software, and to permit persons to whom the
%% Software is furnished to do so, subject to the following
%% conditions:
%%
%% The above copyright notice and this permission notice shall be
%% included in all copies or substantial portions of the Software.
%%
%% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
%% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
%% OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
%% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
%% HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
%% WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
%% OTHER DEALINGS IN THE SOFTWARE.

%%
%% @doc Piqi runtime library
%%
%% Encoding rules follow this specification:
%%
%%      http://code.google.com/apis/protocolbuffers/docs/encoding.html


%
% Initialize Piqirun input buffer from binary()
%
% NOTE: this function is no longer necessary, it remains here for backwards
% compatibility with previous Piqi versions.
-spec init_from_binary(Bytes :: binary()) ->
    % NOTE: in fact, the return type should be piqirun_buffer(). Using specific
    % buffer's variant here to avoid Dialyzer warning.
    TopBlock :: binary().

init_from_binary(Bytes) when is_binary(Bytes) -> Bytes.


%
% The functions below are used by encoders/decoders generated by "piqic erlang"
% -- they are not meant to be used directly.
%

-define(TYPE_VARINT, 0).
-define(TYPE_64BIT, 1).
-define(TYPE_STRING, 2).
-define(TYPE_START_GROUP, 3).
-define(TYPE_END_GROUP, 4).
-define(TYPE_32BIT, 5).


-type field_type() ::
    ?TYPE_VARINT | ?TYPE_64BIT | ?TYPE_STRING |
    ?TYPE_START_GROUP | ?TYPE_END_GROUP | ?TYPE_32BIT.


%% @hidden
-spec encode_field_tag(
    Code :: piqirun_code(),
    FieldType :: field_type()) -> binary().

encode_field_tag(Code, FieldType)
        when is_integer(Code) andalso (Code band 16#3fffffff =:= Code) ->
    encode_varint_value((Code bsl 3) bor FieldType);

encode_field_tag('undefined', FieldType) ->
    % 1 is the default code for top-level primitive types
    encode_field_tag(1, FieldType).


%% @hidden
%% NOTE: `Integer` MUST be >= 0
-spec encode_varint_field(
    Code :: piqirun_code(),
    Integer :: non_neg_integer()) -> iolist().

encode_varint_field(Code, Integer) ->
    [
        encode_field_tag(Code, ?TYPE_VARINT),
        encode_varint_value(Integer)
    ].


%% @hidden
%% NOTE: `I` MUST be >= 0
-spec encode_varint_value(
    I :: non_neg_integer()) -> binary().

encode_varint_value(I) when I >= 0 ->
    encode_varint_1(I, 0, 1).

%% @hidden
-spec encode_varint_value(non_neg_integer(), binary()) -> binary().
encode_varint_value(I, Acc) ->
    <<Acc/binary, (encode_varint_1(I, 0, 1))/binary>>.

-spec encode_varint_1(
        non_neg_integer(),
        non_neg_integer(),
        pos_integer()) -> binary().
encode_varint_1(I, Acc, Pos) when I > 16#7f ->
    Val = I band 16#7f bor 16#80,
    encode_varint_1(I bsr 7, Acc bsl 8 bor Val, Pos + 1);
encode_varint_1(I, Acc, Pos) ->
    <<(Acc bsl 8 bor I):(Pos * 8)>>.

%% @hidden
-spec decode_varint(binary()) ->
    {I :: non_neg_integer(), Remainder :: binary()}.
decode_varint(Bytes) ->
    case decode_varint_1(Bytes) of
        {cont, _, _, _} ->
            % Return the same error as returned by
            % my_split_binary/2 when parsing fields (see
            % below). This way, when there's not enough data for
            % parsing a field, the returned error is the same
            % regardless of where it occured.
            throw_error('not_enough_data');
        I when is_integer(I) -> {I, <<>>};
        Value -> Value
    end.

-type decode_varint_1_cont() :: {cont,
                        non_neg_integer(),
                        non_neg_integer(),
                        non_neg_integer()}.
-type decode_varint_1_ret() :: non_neg_integer()
                      | {non_neg_integer(), binary()}
                      | decode_varint_1_cont().
-spec decode_varint_1(binary()) -> decode_varint_1_ret().
decode_varint_1(<<0:1, A:7>>) -> A;
decode_varint_1(<<0:1, A:7, Rest/binary>>) -> {A, Rest};
decode_varint_1(<<1:1, A:7, 0:1, B:7>>) -> B bsl 7 bor A;
decode_varint_1(<<1:1, A:7, 0:1, B:7, Rest/binary>>) ->
    {B bsl 7 bor A, Rest};
decode_varint_1(<<1:1, A:7, 1:1, B:7, 0:1, C:7>>) ->
    (C bsl 14) bor (B bsl 7) bor A;
decode_varint_1(<<1:1, A:7, 1:1, B:7, 0:1, C:7, Rest/binary>>) ->
    {(C bsl 14) bor (B bsl 7) bor A, Rest};
decode_varint_1(<<1:1, A:7, 1:1, B:7, 1:1, C:7, 0:1, D:7>>) ->
    (D bsl 21) bor (C bsl 14) bor (B bsl 7) bor A;
decode_varint_1(<<1:1, A:7, 1:1, B:7, 1:1, C:7, 0:1, D:7, Rest/binary>>) ->
    {(D bsl 21) bor (C bsl 14) bor (B bsl 7) bor A, Rest};
decode_varint_1(<<1:1, A:7, 1:1, B:7, 1:1, C:7, 1:1, D:7, _/binary>> = Bin) ->
    Acc = (D bsl 21) bor (C bsl 14) bor (B bsl 7) bor A,
    decode_varint_1(Bin, {cont, Acc, 4, 4});
decode_varint_1(Bin) ->
    decode_varint_1(Bin, {cont, 0, 0, 0}).

-spec decode_varint_1(binary(), decode_varint_1_cont()) -> decode_varint_1_ret().
decode_varint_1(Bin, {cont, Acc, X, Offset}) ->
    case Bin of
        <<_:Offset/bytes, 0:1, I:7>> ->
            Acc bor (I bsl (X * 7));
        <<_:Offset/bytes, 0:1, I:7, Rest/binary>> ->
            Result = Acc bor (I bsl (X * 7)),
            {Result, Rest};
        <<_:Offset/bytes, 1:1, I:7>> ->
            {cont, Acc bor (I bsl (X * 7)), X + 1, 0};
        <<_:Offset/bytes, 1:1, I:7, _/binary>> ->
            Acc1 = Acc bor (I bsl (X * 7)),
            decode_varint_1(Bin, {cont, Acc1, X + 1, Offset + 1})
    end.

-spec piqirun_gen_block(Data :: iodata()) -> iolist().

% get length-delimited block, where length is encoded using varint encoding.
piqirun_gen_block(Data) ->
    [ encode_varint_value(iolist_size(Data)), Data ].


-spec piqirun_parse_block(Bytes :: binary()) ->
    {TopBlock :: binary(), Rest :: binary()}.

% parse length-delimited block, rases 'not_enough_data' if there's less data in
% the actual block than the "length" bytes.
piqirun_parse_block(Bytes) ->
    {Length, Rest_1} = decode_varint(Bytes),
    my_split_binary(Rest_1, Length).


-ifndef(EDOC).
-spec piqirun_gen_record(
    Code :: piqirun_code(),
    Fields :: [iolist()] ) -> iolist().

-spec piqirun_gen_variant(
    Code :: piqirun_code(),
    X :: iolist() ) -> iolist().

-spec piqirun_gen_list(
    Code :: piqirun_code(),
    GenValue :: encode_fun(),
    L :: [any()] ) -> iolist().

-spec piqirun_gen_packed_list(
    Code :: piqirun_code(),
    GenValue :: packed_encode_fun(),
    L :: [any()] ) -> iolist().
-endif.


piqirun_gen_record(Code, Fields) ->
    Header =
        case Code of
            'undefined' -> []; % do not generate record header
            _ ->
                [ encode_field_tag(Code, ?TYPE_STRING),
                  encode_varint_value(iolist_size(Fields)) ]
        end,
    [ Header, Fields ].


piqirun_gen_variant(Code, X) ->
    piqirun_gen_record(Code, [X]).


piqirun_gen_list(Code, GenValue, L) ->
    % NOTE: using "1" as list element's code
    piqirun_gen_record(Code, [GenValue(1, X) || X <- L]).


piqirun_gen_packed_list(Code, GenValue, L) ->
    % NOTE: using "1" as list element's code
    Field = piqirun_gen_packed_repeated_field(1, GenValue, L),
    piqirun_gen_record(Code, [Field]).


-type encode_fun() ::
     fun( (Code :: piqirun_code(), Value :: any()) -> iolist() ).

-type packed_encode_fun() ::
     fun( (Value :: any()) -> iolist() ).

-ifndef(EDOC).
-spec piqirun_gen_required_field(
    Code :: piqirun_code(),
    GenValue :: encode_fun(),
    X :: any() ) -> iolist().

-spec piqirun_gen_optional_field(
    Code :: piqirun_code(),
    GenValue :: encode_fun(),
    X :: 'undefined' | any() ) -> iolist().

-spec piqirun_gen_repeated_field(
    Code :: piqirun_code(),
    GenValue :: encode_fun(),
    X :: [any()] ) -> iolist().

-spec piqirun_gen_packed_repeated_field(
    Code :: pos_integer(),
    GenValue :: packed_encode_fun(),
    X :: [any()] ) -> iolist().
-endif.


piqirun_gen_required_field(Code, GenValue, X) ->
    GenValue(Code, X).


piqirun_gen_optional_field(_Code, _GenValue, 'undefined') -> [];
piqirun_gen_optional_field(Code, GenValue, X) ->
    GenValue(Code, X).


piqirun_gen_repeated_field(Code, GenValue, L) ->
    [GenValue(Code, X) || X <- L].


piqirun_gen_packed_repeated_field(_Code, _GenValue, []) ->
    % don't generate anything for empty repeated packed field
    [];
piqirun_gen_packed_repeated_field(Code, GenValue, L) ->
    Contents = [GenValue(X) || X <- L],
    piqirun_gen_record(Code, Contents).


-spec piqirun_gen_flag(
    Code :: piqirun_code(),
    X :: boolean()) -> iolist().

% TODO: remove eventually -- keeping for backward compatibility with older piqi
% which expects flags to only be true if they are present; see
% piqic:transform_flag() for details
piqirun_gen_flag(_Code, 'undefined') -> []; % no flag
piqirun_gen_flag(_Code, false) -> []; % no flag
piqirun_gen_flag(Code, true) -> piqirun_gen_bool_field(Code, true).


-ifndef(EDOC).
-spec piqirun_non_neg_integer_to_varint(
    Code :: piqirun_code(),
    X :: non_neg_integer()) -> iolist().

-spec piqirun_integer_to_signed_varint(
    Code :: piqirun_code(),
    X :: integer()) -> iolist().

-spec piqirun_integer_to_zigzag_varint(
    Code :: piqirun_code(),
    X :: integer()) -> iolist().

-spec piqirun_boolean_to_varint(
    Code :: piqirun_code(),
    X :: boolean()) -> iolist().

-spec piqirun_gen_bool_field(
    Code :: piqirun_code(),
    X :: boolean()) -> iolist().

-spec piqirun_non_neg_integer_to_fixed32(
    Code :: piqirun_code(),
    X :: non_neg_integer()) -> iolist().

-spec piqirun_integer_to_signed_fixed32(
    Code :: piqirun_code(),
    X :: integer()) -> iolist().

-spec piqirun_non_neg_integer_to_fixed64(
    Code :: piqirun_code(),
    X :: non_neg_integer()) -> iolist().

-spec piqirun_integer_to_signed_fixed64(
    Code :: piqirun_code(),
    X :: non_neg_integer()) -> iolist().

-spec piqirun_float_to_fixed64(
    Code :: piqirun_code(),
    X :: number() ) -> iolist().

-spec piqirun_float_to_fixed32(
    Code :: piqirun_code(),
    X :: number() ) -> iolist().

-spec piqirun_binary_to_block(
    Code :: piqirun_code(),
    X :: binary() ) -> iolist().


% NOTE, XXX: in fact, accepting chardata() defined in unicode(3erl) manpage as
% follows:
%
% unicode_binary() = binary() with characters encoded in UTF-8 coding standard
% unicode_char() = integer() representing valid unicode codepoint
%
% chardata() = charlist() | unicode_binary()
% charlist() = [unicode_char() | unicode_binary() | charlist()]
%
-spec piqirun_string_to_block(
    Code :: piqirun_code(),
    X :: string() | binary() ) -> iolist().
-endif.


piqirun_non_neg_integer_to_varint(Code, X) when X >= 0 ->
    encode_varint_field(Code, X).

piqirun_integer_to_signed_varint(Code, X) ->
    encode_varint_field(Code, integer_to_non_neg_integer(X)).

piqirun_integer_to_zigzag_varint(Code, X) ->
    encode_varint_field(Code, integer_to_zigzag_integer(X)).

piqirun_boolean_to_varint(Code, X) ->
    encode_varint_field(Code, boolean_to_non_neg_integer(X)).


%% @hidden
-spec integer_to_non_neg_integer(
    X :: integer()) -> non_neg_integer().

integer_to_non_neg_integer(X) when X >= 0 ->
    X;
integer_to_non_neg_integer(X) ->  % when X < 0
    X + (1 bsl 64).


%% @hidden
-spec integer_to_zigzag_integer(
    X :: integer()) -> non_neg_integer().

integer_to_zigzag_integer(X) when X >= 0 ->
    X bsl 1;
integer_to_zigzag_integer(X) ->  % when X < 0
    bnot (X bsl 1).


boolean_to_non_neg_integer(true) -> 1;
boolean_to_non_neg_integer(false) -> 0.


% helper function
piqirun_gen_bool_field(Code, X) -> piqirun_boolean_to_varint(Code, X).


piqirun_non_neg_integer_to_fixed32(Code, X) when X >= 0 ->
    piqirun_integer_to_signed_fixed32(Code, X).

piqirun_integer_to_signed_fixed32(Code, X) ->
    [encode_field_tag(Code, ?TYPE_32BIT), <<X:32/little-integer>>].


piqirun_non_neg_integer_to_fixed64(Code, X) when X >= 0 ->
    piqirun_integer_to_signed_fixed64(Code, X).

piqirun_integer_to_signed_fixed64(Code, X) ->
    [encode_field_tag(Code, ?TYPE_64BIT), <<X:64/little-integer>>].


piqirun_float_to_fixed64(Code, X) ->
    F = to_float(X),
    [encode_field_tag(Code, ?TYPE_64BIT), <<F:64/little-float>>].


piqirun_float_to_fixed32(Code, X) ->
    F = to_float(X),
    [encode_field_tag(Code, ?TYPE_32BIT), <<F:32/little-float>>].


to_float(X) when is_float(X) -> X;
to_float(X) when is_integer(X) -> X + 0.0.


piqirun_binary_to_block(Code, X) when is_binary(X) ->
    [
        encode_field_tag(Code, ?TYPE_STRING),
        piqirun_gen_block(X)
    ].


piqirun_string_to_block(Code, X) when is_list(X); is_binary(X) ->
    Utf8_bytes =
        case unicode:characters_to_binary(X) of
            Res when is_binary(Res) -> Res;
            Error -> throw_error({'error_encoding_utf8_string', Error})
        end,
    piqirun_binary_to_block(Code, Utf8_bytes).


%
% Generating packed fields (packed encoding is used only for primitive numeric
% types)
%

-ifndef(EDOC).
-spec piqirun_non_neg_integer_to_packed_varint(non_neg_integer()) -> binary().
-spec piqirun_integer_to_packed_signed_varint(integer()) -> binary().
-spec piqirun_integer_to_packed_zigzag_varint(integer()) -> binary().
-spec piqirun_boolean_to_packed_varint(boolean()) -> binary().

-spec piqirun_non_neg_integer_to_packed_fixed32(non_neg_integer()) -> binary().
-spec piqirun_integer_to_packed_signed_fixed32(integer()) -> binary().
-spec piqirun_non_neg_integer_to_packed_fixed64(non_neg_integer()) -> binary().
-spec piqirun_integer_to_packed_signed_fixed64(non_neg_integer()) -> binary().
-spec piqirun_float_to_packed_fixed64(number() ) -> binary().
-spec piqirun_float_to_packed_fixed32(number() ) -> binary().
-endif.


piqirun_non_neg_integer_to_packed_varint(X) when X >= 0 ->
    encode_varint_value(X).

piqirun_integer_to_packed_signed_varint(X) ->
    encode_varint_value(integer_to_non_neg_integer(X)).

piqirun_integer_to_packed_zigzag_varint(X) ->
    encode_varint_value(integer_to_zigzag_integer(X)).

piqirun_boolean_to_packed_varint(X) ->
    encode_varint_value(boolean_to_non_neg_integer(X)).


piqirun_non_neg_integer_to_packed_fixed32(X) when X >= 0 ->
    piqirun_integer_to_packed_signed_fixed32(X).

piqirun_integer_to_packed_signed_fixed32(X) ->
    <<X:32/little-integer>>.


piqirun_non_neg_integer_to_packed_fixed64(X) when X >= 0 ->
    piqirun_integer_to_packed_signed_fixed64(X).

piqirun_integer_to_packed_signed_fixed64(X) ->
    <<X:64/little-integer>>.


piqirun_float_to_packed_fixed64(X) ->
    F = to_float(X),
    <<F:64/little-float>>.


piqirun_float_to_packed_fixed32(X) ->
    F = to_float(X),
    <<F:32/little-float>>.


%
% Decoders and parsers
%

-type parsed_field() :: piqirun_parsed_field().

-spec piqirun_parse_field_header( Bytes :: binary() ) ->
    {Code :: pos_integer(), WireType :: field_type(), Rest :: binary()}.

piqirun_parse_field_header(Bytes) ->
    {Tag, Rest} = decode_varint(Bytes),
    Code = Tag bsr 3,
    WireType = Tag band 7,
    {Code, WireType, Rest}.


-spec piqirun_parse_field(
    Bytes :: binary() ) -> {parsed_field(), Rest :: binary()}.

piqirun_parse_field(Bytes) ->
    {FieldCode, WireType, Content} = piqirun_parse_field_header(Bytes),
    {FieldValue, Rest} =
        case WireType of
            ?TYPE_VARINT -> decode_varint(Content);
            ?TYPE_STRING ->
                {Length, R1} = decode_varint(Content),
                {Value, R2} = my_split_binary(R1, Length),
                {{'block', Value}, R2};
            ?TYPE_64BIT ->
                {Value, R1} = my_split_binary(Content, 8),
                {{'fixed64', Value}, R1};
            ?TYPE_32BIT ->
                {Value, R1} = my_split_binary(Content, 4),
                {{'fixed32', Value}, R1}
        end,
    {{FieldCode, FieldValue}, Rest}.


my_split_binary(X, Pos) when byte_size(X) >= Pos ->
    split_binary(X, Pos);
my_split_binary(_X, _Pos) ->
    throw_error('not_enough_data').


-spec piqirun_parse_field_part(
    Bytes :: binary() ) -> 'undefined' | {parsed_field(), Rest :: binary()}.

% Similar to piqirun_parse_field/1, but if there's not enough data, 'undefined' is
% returned as the result.
piqirun_parse_field_part(Bytes) ->
    try
        piqirun_parse_field(Bytes)
    catch
        % raised in either piqirun_parse_field_header/1 or in piqirun_parse_field/1 meaning that
        % there's not enough data
        {'piqirun_error', 'not_enough_data'} -> 'undefined'
    end.


-ifndef(EDOC).
-spec piqirun_parse_record(
    piqirun_buffer() ) -> [ parsed_field() ].

-spec piqirun_parse_record_buf(
    Bytes :: binary() ) -> [ parsed_field() ].

-spec piqirun_parse_variant(
    piqirun_buffer() ) -> parsed_field().

-spec piqirun_parse_list(
    ParseValue :: decode_fun(),
    piqirun_buffer() ) -> [ any() ].

-spec piqirun_parse_packed_list(
    ParsePackedValue :: packed_decode_fun(),
    ParseValue :: decode_fun(),
    piqirun_buffer() ) -> [ any() ].
-endif.


piqirun_parse_record({'block', Bytes}) ->
    piqirun_parse_record_buf(Bytes);
piqirun_parse_record(TopBlock) when is_binary(TopBlock) ->
    piqirun_parse_record_buf(TopBlock).


piqirun_parse_record_buf(Bytes) ->
    piqirun_parse_record_buf_ordered(Bytes, []).

piqirun_parse_record_buf_ordered(<<>>, Accu) ->
    lists:reverse(Accu);
piqirun_parse_record_buf_ordered(Bytes, Accu) ->
    {Field, Rest} = piqirun_parse_field(Bytes),
    {Code, _Value} = Field,
    % check if the fields appear in order
    case Accu of
        [{PrevCode, _}|_] when PrevCode > Code ->
            % the field is out of order
            piqirun_parse_record_buf_unordered(Rest, [Field | Accu]);
        _ ->
            piqirun_parse_record_buf_ordered(Rest, [Field | Accu])
    end.

piqirun_parse_record_buf_unordered(<<>>, Accu) ->
    Res = lists:reverse(Accu),
    % stable-sort the obtained fields by codes
    lists:keysort(1, Res);
piqirun_parse_record_buf_unordered(Bytes, Accu) ->
    {Field, Rest} = piqirun_parse_field(Bytes),
    piqirun_parse_record_buf_unordered(Rest, [Field | Accu]).


piqirun_parse_variant(X) ->
    [Res] = piqirun_parse_record(X),
    Res.


piqirun_parse_list(ParseValue, X) ->
    Fields = piqirun_parse_record(X),
    [ piqirun_parse_list_elem(ParseValue, F) || F <- Fields ].


% NOTE: expecting "1" as list element's code
piqirun_parse_list_elem(ParseValue, {1, X}) ->
    ParseValue(X).


piqirun_parse_packed_list(ParsePackedValue, ParseValue, X) ->
    Fields = piqirun_parse_record(X),
    L = [ piqirun_parse_packed_list_elem(ParsePackedValue, ParseValue, F) || F <- Fields ],
    lists:append(L).


% NOTE: expecting "1" as list element's code
piqirun_parse_packed_list_elem(ParsePackedValue, ParseValue, {1, X}) ->
    piqirun_parse_packed_field(ParsePackedValue, ParseValue, X).


-spec find_fields(
        Code :: pos_integer(),
        L :: [ parsed_field() ] ) ->
    { Found ::[ piqirun_return_buffer() ], Rest :: [ parsed_field() ]}.

% find all fields with the given code in the list of fields sorted by codes
find_fields(Code, L) ->
    find_fields(Code, L, _Accu = []).


find_fields(Code, [{Code, Value} | T], Accu) ->
    find_fields(Code, T, [Value | Accu]);
find_fields(Code, [{NextCode, _} | T], Accu) when NextCode < Code ->
    % skipping the field which code is less than the requested one
    find_fields(Code, T, Accu);
find_fields(_Code, Rest, Accu) ->
    {lists:reverse(Accu), Rest}.


-spec find_field(
        Code :: pos_integer(),
        L :: [ parsed_field() ] ) ->
    { Found :: 'undefined' | piqirun_return_buffer(), Rest :: [ parsed_field() ]}.

% find the last instance of a field given its code in the list of fields sorted
% by codes
find_field(Code, [{Code, Value} | T]) ->
    % check if this is the last instance of it, if not, continue iterating
    % through the list
    try_find_next_field(Code, Value, T);
find_field(Code, [{NextCode, _Value} | T]) when NextCode < Code ->
    % skipping the field which code is less than the requested one
    find_field(Code, T);
find_field(_Code, Rest) -> % not found
    {'undefined', Rest}.


try_find_next_field(Code, _PrevValue, [{Code, Value} | T]) ->
    % field is found again
    try_find_next_field(Code, Value, T);
try_find_next_field(_Code, PrevValue, Rest) ->
    % previous field was the last one
    {PrevValue, Rest}.


-spec throw_error(any()) -> no_return().

throw_error(X) ->
    throw({'piqirun_error', X}).


-type decode_fun() :: fun( (piqirun_buffer()) -> any() ).

-type packed_decode_fun() :: fun( (binary()) -> {any(), binary()} ).

-ifndef(EDOC).
-spec piqirun_parse_required_field(
    Code :: pos_integer(),
    ParseValue :: decode_fun(),
    L :: [parsed_field()] ) -> { Res :: any(), Rest :: [parsed_field()] }.

-spec piqirun_parse_optional_field(
    Code :: pos_integer(),
    ParseValue :: decode_fun(),
    L :: [parsed_field()] ) -> { Res :: 'undefined' | any(), Rest :: [parsed_field()] }.

-spec piqirun_parse_optional_field(
    Code :: pos_integer(),
    ParseValue :: decode_fun(),
    L :: [parsed_field()],
    Default :: binary() ) -> { Res :: any(), Rest :: [parsed_field()] }.

-spec piqirun_parse_repeated_field(
    Code :: pos_integer(),
    ParseValue :: decode_fun(),
    L :: [parsed_field()] ) -> { Res :: [any()], Rest :: [parsed_field()] }.

-spec piqirun_parse_packed_repeated_field(
    Code :: pos_integer(),
    ParsePackedValue :: packed_decode_fun(),
    ParseValue :: decode_fun(),
    L :: [parsed_field()] ) -> { Res :: [any()], Rest :: [parsed_field()] }.

-spec piqirun_parse_flag(
    Code :: pos_integer(),
    L :: [parsed_field()] ) -> { Res :: boolean(), Rest :: [parsed_field()] }.
-endif.


piqirun_parse_required_field(Code, ParseValue, L) ->
    case piqirun_parse_optional_field(Code, ParseValue, L) of
        {'undefined', _Rest} -> throw_error({'missing_field', Code});
        X -> X
    end.


piqirun_parse_optional_field(Code, ParseValue, L, Default) ->
    case piqirun_parse_optional_field(Code, ParseValue, L) of
        {'undefined', Rest} ->
            Res = ParseValue(Default),
            {Res, Rest};
        X -> X
    end.


piqirun_parse_optional_field(Code, ParseValue, L) ->
    {Field, Rest} = find_field(Code, L),
    Res = 
        case Field of
            'undefined' -> 'undefined';
            X ->
                % NOTE: handling field duplicates without failure
                % XXX, TODO: produce a warning
                ParseValue(X)
        end,
    {Res, Rest}.


% TODO: remove eventually -- keeping for backward compatibility with older piqi
piqirun_parse_flag(Code, L) ->
    % flags are represeted as booleans
    case piqirun_parse_optional_field(Code, fun piqirun_boolean_of_varint/1, L) of
        {'undefined', Rest} -> {false, Rest};
        X = {true, _Rest} -> X;
        {false, _} -> throw_error({'invalid_flag_encoding', Code})
    end.


piqirun_parse_repeated_field(Code, ParseValue, L) ->
    {Fields, Rest} = find_fields(Code, L),
    Res = [ ParseValue(X) || X <- Fields ],
    {Res, Rest}.


piqirun_parse_packed_repeated_field(Code, ParsePackedValue, ParseValue, L) ->
    {Fields, Rest} = find_fields(Code, L),
    Res = [ piqirun_parse_packed_field(ParsePackedValue, ParseValue, X) || X <- Fields ],
    {lists:append(Res), Rest}.


piqirun_parse_packed_field(ParsePackedValue, _ParseValue, {'block', Bytes}) ->
    piqirun_parse_packed_values(ParsePackedValue, Bytes, _Accu = []);
% sometimes packed repeated feilds come in as unpacked; we need to support this
% mode -- Google's Protobuf implementation behaves this way
piqirun_parse_packed_field(_ParsePackedValue, ParseValue, X) ->
    [ParseValue(X)].


piqirun_parse_packed_values(_ParseValue, <<>>, Accu) ->
    lists:reverse(Accu);
piqirun_parse_packed_values(ParseValue, Bytes, Accu) ->
    {X, Rest} = ParseValue(Bytes),
    piqirun_parse_packed_values(ParseValue, Rest, [X|Accu]).


% NOTE: kept for backward compatibility
% TODO: remove in the next major release
check_unparsed_fields(_L) -> ok.


-spec piqirun_error_enum_const(X :: any()) -> no_return().

piqirun_error_enum_const(X) -> throw_error({'unknown_enum_const', X}).


-spec piqirun_error_option(
    _X :: any(),
    Code :: piqirun_code()) -> no_return().

piqirun_error_option(_X, Code) -> throw_error({'unknown_option', Code}).


-ifndef(EDOC).
-spec piqirun_non_neg_integer_of_varint(piqirun_buffer()) -> non_neg_integer().
-spec piqirun_integer_of_signed_varint(piqirun_buffer()) -> integer().
-spec piqirun_integer_of_zigzag_varint(piqirun_buffer()) -> integer().
-spec piqirun_boolean_of_varint(piqirun_buffer()) -> boolean().

-spec piqirun_non_neg_integer_of_fixed32(piqirun_buffer()) -> non_neg_integer().
-spec piqirun_integer_of_signed_fixed32(piqirun_buffer()) -> integer().
-spec piqirun_non_neg_integer_of_fixed64(piqirun_buffer()) -> non_neg_integer().
-spec piqirun_integer_of_signed_fixed64(piqirun_buffer()) -> integer().
-spec piqirun_float_of_fixed64(piqirun_buffer()) -> float().
-spec piqirun_float_of_fixed32(piqirun_buffer()) -> float().
-spec piqirun_binary_of_block(piqirun_buffer()) -> binary().
-spec piqirun_binary_string_of_block(piqirun_buffer()) -> binary().
-spec piqirun_list_string_of_block(piqirun_buffer()) -> string().
-endif.


piqirun_parse_toplevel_header(Bytes) ->
    {{FieldCode, FieldValue}, _Rest} = piqirun_parse_field(Bytes),
    case FieldCode of
        1 -> FieldValue;
        _ -> throw_error('invalid_toplevel_header')
    end.


-define(top_block_parser(Name),
    Name(TopBlock) when is_binary(TopBlock) ->
        Name(piqirun_parse_toplevel_header(TopBlock))).


piqirun_non_neg_integer_of_varint(X) when is_integer(X) -> X; ?top_block_parser(
piqirun_non_neg_integer_of_varint).


piqirun_integer_of_signed_varint(X)
        when is_integer(X) andalso (X band 16#8000000000000000 =/= 0) ->
    X - 16#10000000000000000;
piqirun_integer_of_signed_varint(X) when is_integer(X) -> X; ?top_block_parser(
piqirun_integer_of_signed_varint).


piqirun_integer_of_zigzag_varint(X) when is_integer(X) ->
    (X bsr 1) bxor (-(X band 1)); ?top_block_parser(
piqirun_integer_of_zigzag_varint).


piqirun_boolean_of_varint(1) -> true;
piqirun_boolean_of_varint(0) -> false; ?top_block_parser(
piqirun_boolean_of_varint).


piqirun_non_neg_integer_of_fixed32({'fixed32', <<X:32/little-unsigned-integer>>}) -> X; ?top_block_parser(
piqirun_non_neg_integer_of_fixed32).

piqirun_integer_of_signed_fixed32({'fixed32', <<X:32/little-signed-integer>>}) -> X; ?top_block_parser(
piqirun_integer_of_signed_fixed32).


piqirun_non_neg_integer_of_fixed64({'fixed64', <<X:64/little-unsigned-integer>>}) -> X; ?top_block_parser(
piqirun_non_neg_integer_of_fixed64).

piqirun_integer_of_signed_fixed64({'fixed64', <<X:64/little-signed-integer>>}) -> X; ?top_block_parser(
piqirun_integer_of_signed_fixed64).


piqirun_float_of_fixed64({'fixed64', <<X:64/little-float>>}) -> X;
piqirun_float_of_fixed64({'fixed64', X}) -> piqirun_parse_ieee754_64(X); ?top_block_parser(
piqirun_float_of_fixed64).

piqirun_float_of_fixed32({'fixed32', <<X:32/little-float>>}) -> X;
piqirun_float_of_fixed32({'fixed32', X}) -> piqirun_parse_ieee754_32(X); ?top_block_parser(
piqirun_float_of_fixed32).


piqirun_binary_of_block({'block', X}) -> X; ?top_block_parser(
piqirun_binary_of_block).


% NOTE: this function is left for backward compatibility and will be removed in
% future versions
-spec piqirun_string_of_block(piqirun_buffer()) -> binary().
piqirun_string_of_block(X) -> piqirun_binary_of_block(X).


% utf8 string represented as Erlang binary
piqirun_binary_string_of_block(X) ->
    % NOTE, XXX: not validating utf8 on input
    piqirun_binary_of_block(X).


% list containing utf8 string
piqirun_list_string_of_block(X) ->
    Bin = piqirun_binary_of_block(X),
    case unicode:characters_to_list(Bin) of
        Res when is_list(Res) -> Res;
        Error -> throw_error({'error_decoding_utf8_string', Error})
    end.


%
% Parsing packed fields (packed encoding is used only for primitive numeric
% types)
%

-ifndef(EDOC).
-spec piqirun_non_neg_integer_of_packed_varint(binary()) ->
    {non_neg_integer(), Rest :: binary()}.
-spec piqirun_integer_of_packed_signed_varint(binary()) ->
    {integer(), Rest :: binary()}.
-spec piqirun_integer_of_packed_zigzag_varint( binary()) ->
    {integer(), Rest :: binary()}.
-spec piqirun_boolean_of_packed_varint(binary()) ->
    {boolean(), Rest :: binary()}.

-spec piqirun_non_neg_integer_of_packed_fixed32(binary()) ->
    {non_neg_integer(), Rest :: binary()}.
-spec piqirun_integer_of_packed_signed_fixed32(binary()) ->
    {integer(), Rest :: binary()}.
-spec piqirun_non_neg_integer_of_packed_fixed64(binary()) ->
    {non_neg_integer(), Rest :: binary()}.
-spec piqirun_integer_of_packed_signed_fixed64(binary()) ->
    {integer(), Rest :: binary()}.
-spec piqirun_float_of_packed_fixed64(binary()) ->
    {float(), Rest :: binary()}.
-spec piqirun_float_of_packed_fixed32(binary()) ->
    {float(), Rest :: binary()}.
-endif.


piqirun_non_neg_integer_of_packed_varint(Bin) ->
    decode_varint(Bin).

piqirun_integer_of_packed_signed_varint(Bin) ->
    {X, Rest} = decode_varint(Bin),
    {piqirun_integer_of_signed_varint(X), Rest}.

piqirun_integer_of_packed_zigzag_varint(Bin) ->
    {X, Rest} = decode_varint(Bin),
    {piqirun_integer_of_zigzag_varint(X), Rest}.

piqirun_boolean_of_packed_varint(Bin) ->
    {X, Rest} = decode_varint(Bin),
    {piqirun_boolean_of_varint(X), Rest}.


piqirun_non_neg_integer_of_packed_fixed32(<<X:32/little-unsigned-integer, Rest/binary>>) ->
    {X, Rest};
piqirun_non_neg_integer_of_packed_fixed32(_) -> throw_error('not_enough_data').


piqirun_integer_of_packed_signed_fixed32(<<X:32/little-signed-integer, Rest/binary>>) ->
    {X, Rest};
piqirun_integer_of_packed_signed_fixed32(_) -> throw_error('not_enough_data').


piqirun_non_neg_integer_of_packed_fixed64(<<X:64/little-unsigned-integer, Rest/binary>>) ->
    {X, Rest};
piqirun_non_neg_integer_of_packed_fixed64(_) -> throw_error('not_enough_data').


piqirun_integer_of_packed_signed_fixed64(<<X:64/little-signed-integer, Rest/binary>>) ->
    {X, Rest};
piqirun_integer_of_packed_signed_fixed64(_) -> throw_error('not_enough_data').


piqirun_float_of_packed_fixed64(<<X:64/little-float, Rest/binary>>) ->
    {X, Rest};
piqirun_float_of_packed_fixed64(<<X:8/binary, Rest/binary>>) ->
    {piqirun_parse_ieee754_64(X), Rest};
piqirun_float_of_packed_fixed64(_) ->
    throw_error('not_enough_data').


piqirun_float_of_packed_fixed32(<<X:32/little-float, Rest/binary>>) ->
    {X, Rest};
piqirun_float_of_packed_fixed32(<<X:4/binary, Rest/binary>>) ->
    {piqirun_parse_ieee754_32(X), Rest};
piqirun_float_of_packed_fixed32(_) ->
    throw_error('not_enough_data').


% parse special IEEE 754 values: infinities and NaN
%
% TODO: first, need to modify types and extend returned and accepted floating
% point type to be:
%
%       -type piqi_float() :: float() | '-infinity' | 'infinity' | 'nan'.
%
-ifndef(EDOC).
-spec piqirun_parse_ieee754_64(<<_:64>>) -> no_return().
-spec piqirun_parse_ieee754_32(<<_:32>>) -> no_return().
-endif.

piqirun_parse_ieee754_64(_) -> throw_error('ieee754_infinities_NaN_not_supported_yet').
piqirun_parse_ieee754_32(_) -> throw_error('ieee754_infinities_NaN_not_supported_yet').


-spec piqirun_gen_parsed_field(parsed_field()) -> iolist().

piqirun_gen_parsed_field({Code, Integer}) when is_integer(Integer) -> % XXX: check if Integer >= 0
    encode_varint_field(Code, Integer);
piqirun_gen_parsed_field({Code, {'fixed32', Binary}}) -> % XXX: validate input type and size?
    [encode_field_tag(Code, ?TYPE_32BIT), Binary];
piqirun_gen_parsed_field({Code, {'fixed64', Binary}}) -> % XXX: validate input type and size?
    [encode_field_tag(Code, ?TYPE_64BIT), Binary];
piqirun_gen_parsed_field({Code, {'block', Binary}}) -> % XXX: validate input type?
    [encode_field_tag(Code, ?TYPE_STRING), piqirun_gen_block(Binary)].

